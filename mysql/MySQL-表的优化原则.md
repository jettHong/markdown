## 表的优化原则

### 1、定长与变长分离。

text、blob这种变长字段适合单放一张表，用业务字段关联起来。

### 2、常用字段与不常用字段分离。

需要结合具体业务，剥离查询频度底的字段（拆分大表）。

### 3、适当冗余字段（反范式）。

常见于冗余码表（业务需求）、业务统计数值（避免每次查询都统计一次）。

## 列选择原则

### 1、字段类型优先级

整型 > date、time > enum char > varchar > blob、text

- 整型：定长，没有国家/地区之分，没有字符集的差异。

  比如 tinyint 1,2,3,4,5 <-> char(1) a,b,c,d,e

  从空间上，都是占1个字节，但是orderby 排序，前者快

  原因:后者需要考虑字符集与校对集(就是排序规则)

- time：优点：定长运算快.节省空间。缺点：考虑时区，写sgl时不方便 where> '2005-10-12';

- enum：能起到约束值的作用。因为内部用整型来存储，所以与char联查时内部要经历串与值的转化。

- char：定长，考虑字符集和排序、校对集

- varchar：不定长要考虑字符集的转换与排序时的校对集.速度慢。（旧知识点） 
- text/ Blob：无法使用内存临时表(排序等操怍只能在磁盘上进行) 

附:关于date time的选择，大师的明确意见，直接选 int unsgined not null 存储时间戳

https://www.xaprb.com/blog/2014/01/30/timestamps-in-mysql

### 2、字段长度原则

够用即可，兼顾长远。

原因：大的字段浪费内存影响速度。 

### 3、尽量避免用NULL

原因：NULL不利于索引，要用特殊的字节来标注。

在磁盘上占据的空间其实更大（MySQL 5.7 已对 null 做了改进，但查询仍是不便）

### 4、主键设计

#### 原则

- 业务无关

- 单列，提高连接及筛选效率

- 永远不要更新主键（貌似废话）

- 不包含变化的数据，如时间戳、创建时间、修改时间，避免时间回朔

- 由计算机生成

#### 常见方案

##### 自增ID

优点：

1. 数据库自动编号，速度快，而且是增量增长，聚集型主键按顺序存放，对于检索非常有利。

2. 数字型，占用空间小，易排序，在程序中传递方便。

缺点：

1. 不支持水平分片架构，水平分片的设计当中，这种方法显然不能保证全局唯一。

2. 表锁（旧数据库问题）

3. 自增主键不连续

##### UUID

优点：

1. 全局唯一性、安全性、可移植性。

2. 能够保证独立性，程序可以在不同的数据库间迁移，效果不受影响。

3. 保证生成的ID不仅是表独立的，而且是库独立的，在你切分数据库的时候尤为重要

缺点：

1. InnoDB为聚集主键类型的引擎，数据会按照主键进行排序，由于UUID的无序性会引起数据位置频繁变动，严重影响性能。
2. UUID长度过长，一个UUID占用128个比特（16个字节）。主键索引KeyLength长度过大，而影响能够基于内存的索引记录数量，进而影响基于内存的索引命中率，而基于硬盘进行索引查询性能很差。严重影响数据库服务器整体的性能表现。

  